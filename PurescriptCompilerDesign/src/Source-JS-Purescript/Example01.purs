module Example.One where

-- Here we will cover all the basic compiler translaitions.

-- A small code


data SomeType = A String | B String

main :: SomeType -> String
main (A s) = s
main (B s) = s
-- individual function typecheck happens and then it checks all the cases are considered.

{-

Code which is generated after the core runs on the code. Basically no types are left at this step.
This code can be convereted to JS or purescript code. 
Type verification.

What is the use of externs.json?
Why does the module import itself?
"decls" has the information of datatype associated with the type in a reverse order.
What are each paramteres in the [] of "decls"? 

this output is from the command 
$ pulp --watch build -- --dump-corefn

{
	"Example.One": {
		"imports": ["Example.One", "Prim"],
		"builtWith": "0.11.7",
		"exports": ["A", "B", "main"],
		"decls": [{
			"A": ["Constructor", "SomeType", "A", ["value0"]]
		}, {
			"B": ["Constructor", "SomeType", "B", ["value0"]]
		}, {
			"main": ["Abs", "v", ["Case", [
					["Var", "v"]
				],
				[
					[
						[
							["ConstructorBinder", "Example.One.SomeType", "Example.One.A", [
								["VarBinder", "someType"]
							]]
						],
						["Var", "someType"]
					],
					[
						[
							["ConstructorBinder", "Example.One.SomeType", "Example.One.B", [
								["VarBinder", "someType"]
							]]
						],
						["Var", "someType"]
					]
				]
			]]
		}],
		"foreign": []
	}
}

-}


{-

Output after the execution of purescript compiler
Things that vanished after the JSON version was converted to JS code.
-- import of prim is not there
-- there is no SomeType left in the code.

// Generated by purs version 0.11.7
"use strict";
var A = (function () {
    function A(value0) {
        this.value0 = value0;
    };
    A.create = function (value0) {
        return new A(value0);
    };
    return A;
})();
var B = (function () {
    function B(value0) {
        this.value0 = value0;
    };
    B.create = function (value0) {
        return new B(value0);
    };
    return B;
})();
var main = function (v) {
    if (v instanceof A) {
        return v.value0;
    };
    if (v instanceof B) {
        return v.value0;
    };
    throw new Error("Failed pattern match at Example.One line 10, column 1 - line 10, column 27: " + [ v.constructor.name ]);
};
module.exports = {
    A: A,
    B: B,
    main: main
};



-}

{-

Where does the orchestration of this code start? Basically where is the equivalent of this?
modl :: FilePath -> L.Text -> CompilerM ()
modl fname
    = parseP fname
  >=> dataP
  >=> groupP
  >=> renameP
  >=> desugarP
  >=> inferP
  >=> evalP

Orchestration is happening here
https://github.com/purescript/purescript/tree/master/src/Language/PureScript/Interactive

and here
https://github.com/purescript/purescript/blob/master/src/Language/PureScript/Make

and here
https://github.com/purescript/purescript/tree/master/src/Language/PureScript/Ide

-}

{-
Parser

How it actually works

In our code above we have the following
- Datatype definition
data SomeType = A String | B String

- type
main :: SomeType -> String

- main
main (A someType) = someType
main (B someType) = someType


** What is the meaning of qualified in "import qualified Text.Parsec as P" 
    https://github.com/purescript/purescript/blob/f8ca834ebe3d8e5d484e5b55b5d1b8b6f0a783a2/src/Language/PureScript/Parser/Common.hs#L18
    This is basically call to the haskell parsec library
    ?working of parsec library?


Common.hs
https://github.com/purescript/purescript/blob/master/src/Language/PureScript/Parser/Common.hs
This is responsibe for the orchestration of the parser. All the following module are called from here.
-- | Run a parser
runTokenParser :: FilePath -> TokenParser a -> [PositionedToken] -> Either P.ParseError a
runTokenParser filePath p = P.runParser p (ParseState 0) filePath


Lexer 
https://github.com/purescript/purescript/blob/master/src/Language/PureScript/Parser/Lexer.hs
This tokenises whole code

Kinds.hs
https://github.com/purescript/purescript/blob/master/src/Language/PureScript/Parser/Kinds.hs
This is there to parse all the kinds
?There are no kinds in the above code so this won't be called?

Types.hs
https://github.com/purescript/purescript/blob/master/src/Language/PureScript/Parser/Types.hs
This is there for parsing just the types

Parser State.hs
https://github.com/purescript/purescript/blob/master/src/Language/PureScript/Parser/State.hs
It has just the indentation to decide the scope of the program.

-}